
https://doc.rust-lang.org/rust-by-example/scope/lifetime/explicit.html

================================================================================================================================
                                            Cargo base commands:
================================================================================================================================

▪ Version:
   >  cargo --version

▪ Create a new project
   >  cargo new hello_cargo
   >  cd hello_cargo

▪ Configuration
    in the 'Cargo.toml' file

▪ Build and RUn
   >  cargo build
   >  cargo build --release
   >  cargo run



================================================================================================================================
                                            Questions:
================================================================================================================================

• Ownership & Borrowing
• Traits & Generics
• Error Handling
• Multithreading

• asynchronous programming
  - async/await
  - tokio
  - futures

• cryptographic libraries
  - ring
  - rustls
  - libsodium

================================================================================================================================
                                            TODO:
================================================================================================================================

• Multithreading:
  - std::thread
  - Mutex
  - Atomic
  - Weak       <--- ' non-owning Weak pointer - to break cycles'
  - Once
  - OnceLock
  - LazyLock
  - RwLock
  - Arc
  - Barrier
  - Condvar
  - mpmc   (std::sync::mpmc::channel)
  - mpsc   (std::sync::mpsc::channel)


• Smart Pointers  # https://doc.rust-lang.org/book/ch15-00-smart-pointers.html



• Generics


   fn add<T>(i: Т, j: Т) -> Т 
   {
      i + j
   }

   # Фрагмент <Т: std: : ops: : Add<Output = Т>> предписывает, что в т должна быть реализация операции s td: : ops : : Add.

   fn add<T: std::ops::Add<Output = T>>(i: Т, j: Т) -> Т {
   {
      i + j
   }



================================================================================================================================
                                            Multithreading:  STUDY
================================================================================================================================

• Atomic


   use std::sync::Arc;
   use std::sync::atomic::{AtomicUsize, Ordering};
   use std::thread;

   let val = Arc::new(AtomicUsize::new(5));

   for _ in 0..10 {
       let val = Arc::clone(&val);

       thread::spawn(move || {
           let v = val.fetch_add(1, Ordering::Relaxed);
           println!("{v:?}");
       });
   }
   

• 
   use std::sync::{Arc, Mutex};

   fn example() {
       // defining the counter variable
       let counter = Arc::new(Mutex::new(0));
       // lock the mutex to borrow
       // it is automatically released when the borrow ends
       let mut counter_lock = counter.lock().unwrap();
       *counter_lock = *counter_lock + 1;
   }