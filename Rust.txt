
https://doc.rust-lang.org/rust-by-example/scope/lifetime/explicit.html

================================================================================================================================
                                            Cargo base commands:
================================================================================================================================

▪ Version:
   >  cargo --version

▪ Create a new project
   >  cargo new hello_cargo
   >  cd hello_cargo

▪ Configuration
    in the 'Cargo.toml' file

▪ Build and RUn
   >  cargo build
   >  cargo build --release
   >  cargo run



================================================================================================================================
                                            Questions:
================================================================================================================================

• Ownership & Borrowing
• Traits & Generics
• Error Handling
• Multithreading

• asynchronous programming
  - async/await
  - tokio
  - futures

• cryptographic libraries
  - ring
  - rustls
  - libsodium

================================================================================================================================
                                            TODO:
================================================================================================================================

• Multithreading:
  - std::thread
  - Mutex
  - Atomic
  - Weak       <--- ' non-owning Weak pointer - to break cycles'
  - Once
  - OnceLock
  - LazyLock
  - RwLock
  - Arc
  - Barrier
  - Condvar
  - mpmc   (std::sync::mpmc::channel)
  - mpsc   (std::sync::mpsc::channel)


• Smart Pointers  # https://doc.rust-lang.org/book/ch15-00-smart-pointers.html



• Generics


   fn add<T>(i: Т, j: Т) -> Т 
   {
      i + j
   }

   # Фрагмент <Т: std: : ops: : Add<Output = Т>> предписывает, что в т должна быть реализация операции s td: : ops : : Add.

   fn add<T: std::ops::Add<Output = T>>(i: Т, j: Т) -> Т {
   {
      i + j
   }



================================================================================================================================
                                            Multithreading:  STUDY
================================================================================================================================


https://nuancesprog.ru/p/22996/


• Atomic


   use std::sync::Arc;
   use std::sync::atomic::{AtomicUsize, Ordering};
   use std::thread;

   let val = Arc::new(AtomicUsize::new(5));

   for _ in 0..10 {
       let val = Arc::clone(&val);

       thread::spawn(move || {
           let v = val.fetch_add(1, Ordering::Relaxed);
           println!("{v:?}");
       });
   }




   use std::sync::{ atomic::{AtomicU32, Ordering}, Arc };

   fn example() 
   {
       // define the counter variable
       let counter = Arc::new(AtomicU32::new(0));

       // increment the counter
       // no lock or mutable borrow is necessary
       counter.fetch_add(1, Ordering::SeqCst);
   }



• 
   use std::sync::{Arc, Mutex};

   fn example() {
       // defining the counter variable
       let counter = Arc::new(Mutex::new(0));
       // lock the mutex to borrow
       // it is automatically released when the borrow ends
       let mut counter_lock = counter.lock().unwrap();
       *counter_lock = *counter_lock + 1;
   }



fn main() {
    let user_original = Arc::new(Mutex::new(User { name: String::from("sam") }));

    let user = user_original.clone();
    let t1 = thread::spawn(move || {
        let mut locked_user = user.lock().unwrap();
        locked_user.name = String::from("sam");
        // После того как «locked_user» выйдет из области видимости, мьютекс снова разблокируется.
        // Чтобы разблокировать его явно, применяется
        // «drop(locked_user)».
    });

    let user = user_original.clone();
    let t2 = thread::spawn(move || {
        sleep(Duration::from_millis(10));

        // Выведется «Hello sam»
        println!("Hello {}", user.lock().unwrap().name);
    });

    t1.join().unwrap();
    t2.join().unwrap();
}   