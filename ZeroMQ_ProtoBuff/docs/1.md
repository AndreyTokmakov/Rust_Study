–ù–∏–∂–µ ‚Äî **–ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∏ —Ä–∞–±–æ—á–∏–µ –ø—Ä–∏–º–µ—Ä—ã `Rust + Protobuf + ZeroMQ`**, –æ—Ç –ø—Ä–æ—Å—Ç–æ–≥–æ –∫ –±–æ–ª–µ–µ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–º—É.
–í—Å–µ –ø—Ä–∏–º–µ—Ä—ã –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ **–Ω–∏–∑–∫–∏–µ –∑–∞–¥–µ—Ä–∂–∫–∏ –∏ production-–ø–æ–¥—Ö–æ–¥** (—Ç–æ, —á—Ç–æ —Ç–µ–±–µ –±–ª–∏–∑–∫–æ –ø–æ –ø—Ä–µ–¥—ã–¥—É—â–∏–º —Ç–µ–º–∞–º).

–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤ –∫–æ–¥–µ ‚Äî **–Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º**, –∫–∞–∫ —Ç—ã –ø—Ä–æ—Å–∏–ª.

---

# üß± –°—Ç–µ–∫

* **Protobuf** ‚Üí `prost`
* **ZeroMQ** ‚Üí `zmq` crate (bindings –∫ libzmq)
* –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç ‚Üí `REQ/REP`, `PUB/SUB`, `ROUTER/DEALER`

---

# üì¶ Cargo.toml

```toml
[dependencies]
prost = "0.12"
prost-types = "0.12"
zmq = "0.10"

[build-dependencies]
prost-build = "0.12"
```

---

# üßæ 1. Protobuf schema

`proto/message.proto`

```proto
syntax = "proto3";

package example;

message Ping {
  uint64 seq = 1;
}

message Pong {
  uint64 seq = 1;
}

message Envelope {
  oneof payload {
    Ping ping = 1;
    Pong pong = 2;
  }
}
```

---

# üèó build.rs

```rust
fn main() {
    prost_build::compile_protos(
        &["proto/message.proto"],
        &["proto"],
    ).unwrap();
}
```

---

# üìÅ lib.rs

```rust
pub mod proto {
    include!(concat!(env!("OUT_DIR"), "/example.rs"));
}
```

---

# üîÅ 2. Encode / Decode helpers

```rust
use prost::Message;

pub fn encode<M: Message>(msg: &M) -> Vec<u8> {
    let mut buf = Vec::with_capacity(msg.encoded_len());
    msg.encode(&mut buf).unwrap();
    buf
}

pub fn decode<T: Message + Default>(data: &[u8]) -> T {
    T::decode(data).unwrap()
}
```

---

# üîµ 3. ZeroMQ REQ / REP + Protobuf

## üü¢ Server (REP)

```rust
use zmq::Context;
use prost::Message;
use crate::proto::{Envelope, envelope::Payload, Pong};

fn main() {
    let ctx = Context::new();
    let socket = ctx.socket(zmq::REP).unwrap();
    socket.bind("tcp://*:5555").unwrap();

    loop {
        let msg = socket.recv_bytes(0).unwrap();
        let env = Envelope::decode(&msg[..]).unwrap();

        if let Some(Payload::Ping(ping)) = env.payload {
            println!("Ping received: {}", ping.seq);

            let reply = Envelope {
                payload: Some(Payload::Pong(Pong { seq: ping.seq })),
            };

            let mut buf = Vec::new();
            reply.encode(&mut buf).unwrap();
            socket.send(buf, 0).unwrap();
        }
    }
}
```

---

## üîµ Client (REQ)

```rust
use zmq::Context;
use prost::Message;
use crate::proto::{Envelope, envelope::Payload, Ping};

fn main() {
    let ctx = Context::new();
    let socket = ctx.socket(zmq::REQ).unwrap();
    socket.connect("tcp://127.0.0.1:5555").unwrap();

    let ping = Envelope {
        payload: Some(Payload::Ping(Ping { seq: 42 })),
    };

    let mut buf = Vec::new();
    ping.encode(&mut buf).unwrap();
    socket.send(buf, 0).unwrap();

    let reply = socket.recv_bytes(0).unwrap();
    let env = Envelope::decode(&reply[..]).unwrap();

    println!("Reply: {:?}", env);
}
```

---

# üì° 4. PUB / SUB + Protobuf (Market Data style)

## Publisher

```rust
use zmq::Context;
use prost::Message;
use crate::proto::{Envelope, envelope::Payload, Ping};

fn main() {
    let ctx = Context::new();
    let pub_socket = ctx.socket(zmq::PUB).unwrap();
    pub_socket.bind("tcp://*:6000").unwrap();

    let mut seq = 0;

    loop {
        seq += 1;

        let msg = Envelope {
            payload: Some(Payload::Ping(Ping { seq })),
        };

        let mut buf = Vec::new();
        msg.encode(&mut buf).unwrap();

        // Topic + protobuf payload
        pub_socket.send("PING", zmq::SNDMORE).unwrap();
        pub_socket.send(buf, 0).unwrap();
    }
}
```

---

## Subscriber

```rust
use zmq::Context;
use prost::Message;
use crate::proto::Envelope;

fn main() {
    let ctx = Context::new();
    let sub = ctx.socket(zmq::SUB).unwrap();
    sub.connect("tcp://127.0.0.1:6000").unwrap();
    sub.set_subscribe(b"PING").unwrap();

    loop {
        let _topic = sub.recv_string(0).unwrap();
        let data = sub.recv_bytes(0).unwrap();

        let env = Envelope::decode(&data[..]).unwrap();
        println!("Received: {:?}", env);
    }
}
```

---

# üß† 5. ROUTER / DEALER + Protobuf (HFT / microservices)

## Router (server)

```rust
use zmq::Context;
use prost::Message;
use crate::proto::{Envelope, envelope::Payload, Pong};

fn main() {
    let ctx = Context::new();
    let router = ctx.socket(zmq::ROUTER).unwrap();
    router.bind("tcp://*:7000").unwrap();

    loop {
        let identity = router.recv_bytes(0).unwrap();
        let _empty = router.recv_bytes(0).unwrap();
        let payload = router.recv_bytes(0).unwrap();

        let env = Envelope::decode(&payload[..]).unwrap();

        let reply = Envelope {
            payload: Some(Payload::Pong(Pong { seq: 999 })),
        };

        let mut buf = Vec::new();
        reply.encode(&mut buf).unwrap();

        router.send(identity, zmq::SNDMORE).unwrap();
        router.send("", zmq::SNDMORE).unwrap();
        router.send(buf, 0).unwrap();
    }
}
```

---

## Dealer (client)

```rust
use zmq::Context;
use prost::Message;
use crate::proto::{Envelope, envelope::Payload, Ping};

fn main() {
    let ctx = Context::new();
    let dealer = ctx.socket(zmq::DEALER).unwrap();
    dealer.connect("tcp://127.0.0.1:7000").unwrap();

    let msg = Envelope {
        payload: Some(Payload::Ping(Ping { seq: 1 })),
    };

    let mut buf = Vec::new();
    msg.encode(&mut buf).unwrap();

    dealer.send(buf, 0).unwrap();

    let reply = dealer.recv_bytes(0).unwrap();
    let env = Envelope::decode(&reply[..]).unwrap();
    println!("Reply: {:?}", env);
}
```

---

# ‚ö° 6. Performance tips (–≤–∞–∂–Ω–æ)

‚úî `Vec::with_capacity(encoded_len())`
‚úî reuse buffers (arena / object pool)
‚úî avoid JSON entirely
‚úî protobuf + ZMQ multipart frames
‚úî pin threads to cores (HFT-style)

---

# üß™ 7. Unit-test Protobuf + ZMQ logic (–±–µ–∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Å–æ–∫–µ—Ç–∞)

```rust
#[test]
fn protobuf_roundtrip() {
    let msg = Envelope {
        payload: Some(Payload::Ping(Ping { seq: 123 })),
    };

    let mut buf = Vec::new();
    msg.encode(&mut buf).unwrap();

    let decoded = Envelope::decode(&buf[..]).unwrap();
    assert!(decoded.payload.is_some());
}
```